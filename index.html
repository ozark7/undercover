<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üé≠ Undercover Online (Host control)</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
    import {
      getDatabase,
      ref,
      set,
      onValue,
      get,
      push,
      update,
      remove
    } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js";

    // --------- CONFIG FIREBASE ----------
    const firebaseConfig = {
      apiKey: "AIzaSyCob3LEUMLwlCXAiGzheIuGmYQhArpHQ_k",
      authDomain: "undercover-37256.firebaseapp.com",
      projectId: "undercover-37256",
      storageBucket: "undercover-37256.firebasestorage.app",
      messagingSenderId: "756599146063",
      appId: "1:756599146063:web:0e9de4a385b2f8c11fcc3a",
      measurementId: "G-EW0ZL3GNTK",
      databaseURL: "https://undercover-37256-default-rtdb.firebaseio.com"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    // --------- Estado local ----------
    let gameId = localStorage.getItem("gameId") || null;
    let playerName = localStorage.getItem("playerName") || "";
    let isHost = false;

    // ---------- DOM helpers ----------
    const $ = id => document.getElementById(id);

    // ---------- Palabras (base, parecido) ----------
    const wordPairs = [
      ["Perro","Lobo"],["Gato","Conejo"],["Playa","Piscina"],
      ["Sol","Luna"],["Caf√©","T√©"],["Avi√≥n","Helic√≥ptero"],
      ["Monta√±a","Colina"],["Libro","Revista"]
    ];

    // ---------- Funciones de sala ----------
    async function createGame(){
      const newRef = push(ref(db,"games"));
      gameId = newRef.key;
      isHost = true;
      localStorage.setItem("gameId", gameId);
      await set(newRef, {
        players: {},
        state: "waiting",
        revealOrder: [],
        revealIndex: 0,
        speakOrder: [],
        spoken: {},
        votes: {},
        lastEliminated: null,
        round: 0
      });
      listenGame(); renderLocalUI();
      alert("Sala creada: " + gameId + " ‚Äî comp√°rtela con tus amigos");
    }

    async function joinGame(){
      const id = prompt("üîë ID sala:");
      if(!id) return;
      const snap = await get(ref(db,`games/${id}`));
      if(!snap.exists()) return alert("Sala no encontrada");
      gameId = id;
      isHost = false;
      localStorage.setItem("gameId", gameId);
      listenGame(); renderLocalUI();
      alert("Te uniste a la sala: " + gameId);
    }

    async function addPlayer(){
      const name = $('playerName').value.trim();
      if(!name) return alert("Escribe tu nombre");
      if(!gameId) return alert("Crea o √∫nete a una sala");
      playerName = name;
      localStorage.setItem("playerName", playerName);
      await set(ref(db,`games/${gameId}/players/${name}`), {
        name, alive: true, role: "unknown", word: ""
      });
      $('playerName').value = "";
    }

    // ---------- Escuchar sala ----------
    function listenGame(){
      if(!gameId) return;
      const r = ref(db,`games/${gameId}`);
      onValue(r, snap => {
        const game = snap.val();
        if(!game) return;
        renderPlayers(game.players || {});
        handleState(game);
      });
    }

    function renderPlayers(players){
      const arr = Object.values(players || {});
      $('playerList').innerHTML = arr.length
        ? arr.map(p => `<li class="p-1">${p.name} ${!p.alive?"üíÄ":""}</li>`).join("")
        : `<li class="text-gray-400 italic">Sin jugadores</li>`;
    }

    // ---------- Manejo de fases ----------
    function handleState(game){
      const state = game.state || "waiting";
      // reset UI
      $('gameArea').classList.add('hidden');
      $('hostControls').classList.add('hidden');
      $('wordReveal').classList.add('hidden');
      $('speakerBox').classList.add('hidden');
      $('votingArea').innerHTML = "";
      $('eliminationBox').innerHTML = "";

      // show main area
      $('gameArea').classList.remove('hidden');
      $('phaseTitle').textContent = {
        waiting: "Esperando jugadores...",
        reveal: "üîí Revelado: pasa el tel√©fono",
        speaking: "üó£Ô∏è Ronda hablada",
        voting: "üó≥Ô∏è Votaci√≥n",
        ended: "üèÅ Juego terminado"
      }[state] || state;

      if(state === 'waiting'){
        if(isHost) $('hostControls').classList.remove('hidden');
        $('wordReveal').classList.add('hidden');
      }

      if(state === 'reveal'){
        // revealOrder and revealIndex control who may see word
        const order = game.revealOrder || [];
        const idx = game.revealIndex || 0;
        const current = order[idx];
        // If you're the current player, show your word button; else hide
        const myWord = (game.players && game.players[playerName] && game.players[playerName].word) || "";
        if(playerName === current){
          $('wordReveal').classList.remove('hidden');
          $('wordText').textContent = myWord ? `Tu palabra: ${myWord}` : "No tienes palabra asignada";
        } else {
          $('wordReveal').classList.add('hidden');
        }
        // host controls
        if(isHost){
          $('hostControls').classList.remove('hidden');
          $('hostNextReveal').classList.remove('hidden');
          $('hostNextReveal').disabled = false;
          $('hostStartSpeaking').classList.remove('hidden');
          $('hostStartSpeaking').disabled = idx < order.length ? true : false; // only enable start speaking when index >= length
        }
      }

      if(state === 'speaking'){
        $('speakerBox').classList.remove('hidden');
        const order = game.speakOrder || [];
        const spoken = game.spoken || {};
        const next = order.find(p => !spoken?.[p]);
        $('speakerText').textContent = next ? `Ahora: ${next}` : 'Todos hablaron';
        if(isHost){
          $('hostControls').classList.remove('hidden');
          $('hostNextSpeakerBtn').classList.remove('hidden');
          $('hostStartVoting').classList.remove('hidden');
          $('hostStartVoting').disabled = !!next; // only enable if no next (i.e., all spoken)
        }
      }

      if(state === 'voting'){
        // render vote buttons for all alive players
        const players = game.players || {};
        const alive = Object.keys(players).filter(p => players[p].alive);
        $('votingArea').innerHTML = alive.map(p => `<button class="voteBtn bg-red-600 px-3 py-2 m-1 rounded" onclick="castVote('${p}')">${p}</button>`).join('');
        if(isHost){
          $('hostControls').classList.remove('hidden');
          $('hostConfirmVotes').classList.remove('hidden');
          $('hostConfirmVotes').disabled = false;
        }
      }

      if(state === 'ended'){
        $('eliminationBox').innerHTML = `<div class="p-3 bg-gray-800 rounded">${game.result || 'Partida finalizada'}</div>`;
      }

      // last eliminated show
      if(game.lastEliminated){
        $('eliminationBox').innerHTML = `<div class="p-3 bg-gray-800 rounded">√öltimo eliminado: <b>${game.lastEliminated.name}</b> ‚Äî rol: <b>${game.lastEliminated.role}</b></div>`;
      }
    }

    // ---------- Iniciar partida (host) ----------
    async function startGame(){
      if(!isHost) return alert("Solo el host puede iniciar");
      const snap = await get(ref(db,`games/${gameId}/players`));
      const players = Object.keys(snap.val() || {});
      if(players.length < 3) return alert("M√≠nimo 3 jugadores");

      // pick word pair and two special roles (undercover + mrwhite)
      const pair = wordPairs[Math.floor(Math.random() * wordPairs.length)];
      // shuffle players
      const shuffled = [...players].sort(()=>Math.random()-0.5);
      const undercover = shuffled[0];
      const mrwhite = shuffled[1];

      // assign roles & words
      for(const p of players){
        let role = 'civil', word = pair[0];
        if(p === undercover){ role='undercover'; word = pair[1]; }
        if(p === mrwhite){ role='mrwhite'; word = '???'; }
        await update(ref(db,`games/${gameId}/players/${p}`), { role, word });
      }

      // create reveal order (random)
      const revealOrder = [...players].sort(()=>Math.random()-0.5);
      // speaking order will be separate (random)
      const speakOrder = [...players].sort(()=>Math.random()-0.5);

      await update(ref(db,`games/${gameId}`), {
        state: 'reveal',
        revealOrder,
        revealIndex: 0,
        speakOrder,
        spoken: {},
        votes: {},
        lastEliminated: null,
        round: (await get(ref(db,`games/${gameId}/round`))).val() ? (await get(ref(db,`games/${gameId}/round`))).val()+1 : 1
      });
    }

    // ---------- Host: advance reveal (host clicks when they want next player to view) ----------
    async function hostNextReveal(){
      if(!isHost) return;
      const snap = await get(ref(db,`games/${gameId}`));
      const game = snap.val();
      const order = game.revealOrder || [];
      let idx = game.revealIndex || 0;
      idx++;
      // if idx >= length -> move to speaking
      if(idx >= order.length){
        await update(ref(db,`games/${gameId}`), { revealIndex: idx, state: 'speaking' });
      } else {
        await update(ref(db,`games/${gameId}`), { revealIndex: idx });
      }
    }

    // ---------- Host: start speaking early (if desired) ----------
    async function hostStartSpeaking(){
      if(!isHost) return;
      await update(ref(db,`games/${gameId}`), { state: 'speaking' });
    }

    // ---------- Host: mark current speaker as 'spoken' and advance ----------
    async function hostNextSpeaker(){
      if(!isHost) return;
      const snap = await get(ref(db,`games/${gameId}`));
      const game = snap.val();
      const order = game.speakOrder || [];
      const spoken = game.spoken || {};
      // find next who hasn't spoken
      const next = order.find(p => !spoken[p]);
      if(!next){
        // nobody left -> go to voting
        await update(ref(db,`games/${gameId}`), { state: 'voting' });
        return;
      }
      // mark them spoken
      spoken[next] = true;
      await update(ref(db,`games/${gameId}/spoken`), spoken);
      // check if any left
      const still = order.find(p => !spoken[p]);
      if(!still){
        await update(ref(db,`games/${gameId}`), { state: 'voting' });
      } else {
        // stay in speaking until host advances again
        await update(ref(db,`games/${gameId}`), { spoken });
      }
    }

    // ---------- Casting vote (player) ----------
    async function castVote(target){
      if(!playerName) return alert("Reg√≠strate antes de votar");
      await update(ref(db,`games/${gameId}/votes/${playerName}`), target);
      // disable vote buttons visually
      document.querySelectorAll('.voteBtn').forEach(b => b.disabled = true);
      // small feedback
      alert("Votaste por: " + target);
    }

    // ---------- Host: confirm votes, eliminate & reveal ----------
    async function hostConfirmVotes(){
      if(!isHost) return;
      const snap = await get(ref(db,`games/${gameId}`));
      const game = snap.val();
      const votes = game.votes || {};
      if(Object.keys(votes).length < 1) return alert("A√∫n no hay votos");

      // tally
      const tally = {};
      Object.values(votes).forEach(v => tally[v] = (tally[v]||0)+1 );
      // find max
      let max = -1, chosen = null;
      for(const [name,count] of Object.entries(tally)){
        if(count > max){ max = count; chosen = name; }
      }
      if(!chosen) return alert("No se pudo determinar");

      // eliminate chosen
      const pSnap = await get(ref(db,`games/${gameId}/players/${chosen}`));
      const pObj = pSnap.val();
      if(!pObj) return alert("Jugador no encontrado");

      await update(ref(db,`games/${gameId}/players/${chosen}`), { alive: false });
      // store last eliminated with role
      await update(ref(db,`games/${gameId}`), { lastEliminated: { name: chosen, role: pObj.role || 'unknown' } });

      // clear votes
      await set(ref(db,`games/${gameId}/votes`), {});

      // if eliminated is mrwhite -> allow guess (we'll implement simple flow: host triggers check after guess)
      if(pObj.role === 'mrwhite'){
        // set a field that mrwhite needs to guess
        await update(ref(db,`games/${gameId}`), { mrwhiteGuessFor: chosen, state: 'mrwhite_guess' });
      } else {
        // continue normally
        await sleep(400);
        await checkWinnerAndNext();
      }
    }

    // ---------- MR WHITE attempt guess (only available if this client is the eliminated mrwhite) ----------
    async function mrWhiteGuess(){
      const guess = prompt("Intento final: adivina la palabra secreta de los civiles:");
      if(guess === null) return;
      // fetch current game's base word: we can retrieve remaining alive civil/undercover words and infer base
      const snap = await get(ref(db,`games/${gameId}`));
      const game = snap.val();
      // find a civil who is alive or even dead who has word != '???'
      const players = game.players || {};
      let sampleWord = null;
      for(const [k,v] of Object.entries(players)){
        if(v.word && v.word !== '???'){ sampleWord = v.word; break; }
      }
      // compare case-insensitive
      if(sampleWord && guess.trim().toLowerCase() === sampleWord.trim().toLowerCase()){
        // mrwhite wins
        await update(ref(db,`games/${gameId}`), { state: 'ended', result: `Mr White adivin√≥ y gana con "${guess}"` });
        alert("Mr White adivin√≥ correctamente. Fin del juego.");
      } else {
        // mrwhite failed -> continue game
        await update(ref(db,`games/${gameId}`), { mrwhiteGuessFor: null, state: 'continue_after_mrwhite_guess' });
        await sleep(400);
        await checkWinnerAndNext();
      }
    }

    // ---------- Check winners and proceed ----------
    async function checkWinnerAndNext(){
      const snap = await get(ref(db,`games/${gameId}`));
      const game = snap.val();
      const players = game.players || {};
      const alive = Object.keys(players).filter(p => players[p].alive);
      const underAlive = alive.find(p => players[p].role === 'undercover');
      const whiteAlive = alive.find(p => players[p].role === 'mrwhite');

      if(!underAlive && !whiteAlive){
        await update(ref(db,`games/${gameId}`), { state: 'ended', result: 'Civiles ganaron' });
        return;
      }
      if(alive.length <= 2 && (underAlive || whiteAlive)){
        await update(ref(db,`games/${gameId}`), { state: 'ended', result: 'Impostores (Undercover/MrWhite) ganaron' });
        return;
      }

      // prepare next round: keep roles/words for survivors, prepare new reveal/speak order
      const newOrder = alive.sort(()=>Math.random()-0.5);
      await update(ref(db,`games/${gameId}`), {
        state: 'reveal',
        revealOrder: newOrder,
        revealIndex: 0,
        speakOrder: newOrder.map(x=>x).sort(()=>Math.random()-0.5),
        spoken: {},
        votes: {},
        lastEliminated: null,
        round: (game.round || 0) + 1
      });
    }

    // ---------- Small util ----------
    const sleep = ms => new Promise(r=>setTimeout(r,ms));

    // ---------- UI wiring ----------
    window.createGame = createGame;
    window.joinGame = joinGame;
    window.addPlayer = addPlayer;
    window.startGame = startGame;
    window.hostNextReveal = hostNextReveal;
    window.hostStartSpeaking = hostStartSpeaking;
    window.hostNextSpeaker = hostNextSpeaker;
    window.hostStartVoting = async ()=> { if(isHost) await update(ref(db,`games/${gameId}`),{ state: 'voting' }); };
    window.castVote = castVote; // alias for inline
    window.hostConfirmVotes = hostConfirmVotes;
    window.mrWhiteGuess = mrWhiteGuess;
    window.hostStartNewRound = async ()=> { await checkWinnerAndNext(); };

    function castVote(target){ return window.castVote = async (t)=>{ await update(ref(db,`games/${gameId}/votes/${playerName}`), t); alert('Votado: '+t); } , window.castVote(target); }

    // ---------- render local host controls visibility ----------
    function renderLocalUI(){
      if(isHost) $('hostControls').classList.remove('hidden'); else $('hostControls').classList.add('hidden');
      // if playerName set, show some UI hints
      if(playerName) $('youName').textContent = `T√∫: ${playerName}`;
    }

    // auto-listen if there's a saved game id
    if(gameId) { listenGame(); renderLocalUI(); }
  </script>

  <style>
    @keyframes glow { 0%,100%{ text-shadow:0 0 20px #9333ea,0 0 40px #a855f7 } 50%{ text-shadow:0 0 40px #c084fc } }
    .glow{animation:glow 2s infinite alternate}
    .neon-border{border:2px solid rgba(147,51,234,0.5);box-shadow:0 0 20px rgba(147,51,234,0.5),0 0 40px rgba(126,34,206,0.4)}
  </style>
</head>
<body class="bg-gradient-to-br from-black via-purple-950 to-gray-900 text-white min-h-screen flex items-center justify-center p-6">
  <div class="w-full max-w-lg neon-border rounded-2xl p-6 bg-gray-900/90 shadow-2xl">
    <h1 class="text-3xl font-extrabold glow text-center mb-4">üé≠ UNDERCOVER</h1>

    <div class="space-y-3">
      <div class="flex gap-2">
        <button id="btnCreate" onclick="createGame()" class="flex-1 bg-green-600 p-2 rounded">üü¢ Crear sala</button>
        <button id="btnJoin" onclick="joinGame()" class="flex-1 bg-indigo-600 p-2 rounded">üîµ Unirse</button>
      </div>

      <div class="flex gap-2">
        <input id="playerName" class="flex-1 p-2 rounded bg-gray-800" placeholder="Tu nombre" />
        <button id="btnAdd" onclick="addPlayer()" class="bg-purple-600 px-3 rounded">‚ûï</button>
      </div>

      <div>
        <h3 class="text-sm text-purple-300">Jugadores</h3>
        <ul id="playerList" class="list-disc pl-6 text-left text-purple-200"></ul>
      </div>

      <!-- Host controls -->
      <div id="hostControls" class="hidden space-y-2">
        <button id="btnStart" onclick="startGame()" class="w-full bg-yellow-500 p-2 rounded">üöÄ Iniciar partida</button>
        <div class="flex gap-2">
          <button id="hostNextReveal" onclick="hostNextReveal()" class="flex-1 bg-blue-600 p-2 rounded hidden">‚è≠Ô∏è Siguiente revelaci√≥n (host)</button>
          <button id="hostMarkDone" onclick="hostNextSpeaker()" class="flex-1 bg-blue-500 p-2 rounded hidden">‚úÖ Marcar hablado (host)</button>
        </div>
        <div class="flex gap-2">
          <button id="hostStartSpeaking" onclick="hostStartSpeaking()" class="flex-1 bg-pink-500 p-2 rounded hidden">‚ñ∂ Iniciar speaking (host)</button>
          <button id="hostStartVoting" onclick="hostStartVoting()" class="flex-1 bg-pink-600 p-2 rounded hidden">üó≥Ô∏è Iniciar votaci√≥n (host)</button>
        </div>
        <div class="flex gap-2">
          <button id="hostConfirmVotes" onclick="hostConfirmVotes()" class="flex-1 bg-red-600 p-2 rounded hidden">üî¥ Confirmar votos / Eliminar</button>
          <button id="hostNewRound" onclick="hostStartNewRound()" class="flex-1 bg-emerald-600 p-2 rounded">üîÅ Nueva ronda</button>
        </div>
      </div>

      <!-- Game area -->
      <div id="gameArea" class="hidden mt-4">
        <h2 id="phaseTitle" class="text-lg font-bold text-purple-300 mb-2"></h2>

        <div id="wordReveal" class="p-3 bg-gray-800 rounded mb-3 hidden">
          <p id="wordText" class="text-2xl text-yellow-300 font-semibold"></p>
          <p class="text-sm text-gray-400 mt-2">Mira la palabra en privado y pasa el tel√©fono.</p>
        </div>

        <div id="speakerBox" class="p-3 bg-gray-800 rounded mb-3 hidden">
          <p id="speakerText" class="text-lg text-purple-200"></p>
          <p class="text-sm text-gray-400 mt-1">El host marcar√° cuando termine cada hablante.</p>
        </div>

        <div id="votingArea" class="mb-3"></div>

        <div id="eliminationBox" class="mb-3"></div>
      </div>

      <div class="text-xs text-gray-400">Nota: las pistas se dicen en voz (por ejemplo en Discord). Aqu√≠ solo sincronizamos turnos, revelados y votaciones.</div>
    </div>
  </div>
</body>
</html>
